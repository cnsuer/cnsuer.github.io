<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Restver's Blog"/><link rel="canonical" href="https://cnsuer.restver.life/posts/oc-webview-promise"/><meta name="twitter:url" content="https://cnsuer.restver.life/posts/oc-webview-promise"/><meta property="og:url" content="https://cnsuer.restver.life/posts/oc-webview-promise"/><title>OC 代码 webview 执行 JS,如何有效的消除回调地狱 | Restver's Blog</title><meta name="twitter:title" content="OC 代码 webview 执行 JS,如何有效的消除回调地狱 | Restver's Blog"/><meta property="og:title" content="OC 代码 webview 执行 JS,如何有效的消除回调地狱 | Restver's Blog"/><meta name="description" content="OC代码webview执行JS,如何有效的消除回调地狱."/><meta name="twitter:description" content="OC代码webview执行JS,如何有效的消除回调地狱."/><meta property="og:description" content="OC代码webview执行JS,如何有效的消除回调地狱."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Restver's Blog"/></head><body class="item-page"><header><div class="wrapper"><div class="logo"><a href="/"><h2>Restver's Blog</h2></a></div><nav><ul><li><a href="/">Index</a></li><li><a class="selected" href="/posts">My posts</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div><h1>OC 代码 webview 执行 JS,如何有效的消除回调地狱</h1></div><div><ul class="tag-list"><li class="tag variant-0"><a href="/tags/oc">oc</a></li><li class="tag variant-2"><a href="/tags/webview">webview</a></li><li class="tag variant-1"><a href="/tags/promise">promise</a></li><li class="tag tagdate">2023-07-22</li></ul><div class="content"><h1>OC 代码 webview 执行 JS,如何有效的消除回调地狱</h1><p>在项目中,偶发的报一个 JS 错误 <code>A lavaScript exception occurred</code> ,找到这段的具体实现</p><pre data-language="jsx" class="hljs"><code><span class="hljs-keyword">const</span> scrDom = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
scrDom.src = basic.min.js;
scrDom.addEventListener(<span class="hljs-string">"load"</span>, () =&gt; {
  <span class="hljs-keyword">if</span> (!haveMacJS) {
    <span class="hljs-built_in">window</span>.webkit.messageHandlers.setPlanSucceed.postMessage(<span class="hljs-string">""</span>);
  }
});
<span class="hljs-keyword">const</span> macScrDom = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
macScrDom.src = mac.min.js;
macScrDom.addEventListener(<span class="hljs-string">"load"</span>, () =&gt; {
  <span class="hljs-built_in">window</span>.webkit.messageHandlers.setPlanSucceed.postMessage(<span class="hljs-string">""</span>);
});
</code></pre><p>发现逻辑是当需要在 <code>webView</code> 中 加载两个精算文件,并且等到这两个精算文件都加载完毕后,再通知 native 端,把参数传回到 webView,执行计算,发现这段代码并不是按顺序执行完,然后才通知 native 端的.</p><p>出现问题的原因是,需要在 JS 端和 Native 端来回传参,无形中增加了问题出现的概率,为了遵循相同逻辑,同一地方处理的原则,就在 native 端加载这两个 JS 文件</p><pre data-language="objectivec" class="hljs"><code><span class="hljs-built_in">NSString</span> *basicString = [<span class="hljs-built_in">NSString</span> stringWithContentsOfFile: basicJsPath encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error: <span class="hljs-literal">nil</span>];
<span class="hljs-comment">// 加载第一个js文件</span>
[webView evaluateJavaScript: basicString completionHandler:^(<span class="hljs-keyword">id</span> _Nullable res, <span class="hljs-built_in">NSError</span> * _Nullable basicError) {
	  <span class="hljs-comment">//如果需要加载第二个文件</span>
		<span class="hljs-keyword">if</span> ([RFileTool existFileAtPath: macroJsPath])
	  {
				<span class="hljs-comment">//第二个精算文件存在的话,加载它</span>
        <span class="hljs-built_in">NSString</span> *macroString = [<span class="hljs-built_in">NSString</span> stringWithContentsOfFile: macroJsPath encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error:<span class="hljs-literal">nil</span>];
        [weakWebView evaluateJavaScript: macroString completionHandler:^(<span class="hljs-keyword">id</span> _Nullable response, <span class="hljs-built_in">NSError</span> * _Nullable macroError) {
            <span class="hljs-comment">// 第二个文件加载成功的话,通知webView,执行初始化操作</span>
            <span class="hljs-built_in">NSString</span> *javaScriptString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"setPlan('%@',%d)"</span>, weakSelf.lastPlanId, <span class="hljs-literal">YES</span>];
            [weakWebView evaluateJavaScript:javaScriptString completionHandler:^(<span class="hljs-keyword">id</span> _Nullable response, <span class="hljs-built_in">NSError</span> * _Nullable error) {
                <span class="hljs-comment">//初始化成功,调用native的计算方法.</span>
								[weakSelf loadCalculate];
            }];
        }];
    }
		<span class="hljs-keyword">else</span>
		{
				<span class="hljs-comment">// 不需要加载第二个精算文件的话,通知webView,执行初始化操作</span>
        <span class="hljs-built_in">NSString</span> *javaScriptString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"setPlan('%@',%d)"</span>, weakSelf.lastPlanId, <span class="hljs-literal">NO</span>];
        [weakWebView evaluateJavaScript:javaScriptString completionHandler:^(<span class="hljs-keyword">id</span> _Nullable response, <span class="hljs-built_in">NSError</span> * _Nullable error) {
            <span class="hljs-comment">//初始化成功,调用native的计算方法.</span>
						[weakSelf loadCalculate];
        }];
		}
}];
</code></pre><p>以上一个的方法中,套了三层回调,这还是省略了处理错误的情况下,如果再加上错误处理,这里的代码将会变的非常的多以及丑陋.</p><p>如果能像其他语言中,Promise 链式调用方式,代码就会变的清晰了,可惜 OC 不支持 Promise,只能自己实现了.</p><p>先看下最终效果,然后讲解具体的实现逻辑,虽然代码量看上去没少多少,但是调用逻辑清晰多了,也没有那么多重复代码了.当然这里每一个 promise 对象都有一个 catch,这里是为了统计具体是哪一个 js 加载出错了,如果不需要这样统计,可以修改代码,统一 catch</p><pre data-language="objectivec" class="hljs"><code><span class="hljs-comment">//promise入口,使用类方法firstlyWithJSEvaluator,创建第一个promise</span>
[[[[[[[RJSEvalPromise firstlyWithJSEvaluator: webView js: ^<span class="hljs-built_in">NSString</span> * (<span class="hljs-keyword">void</span>) {
    <span class="hljs-comment">//返回需要加载的js文件</span>
    <span class="hljs-built_in">NSString</span> *basicString = [<span class="hljs-built_in">NSString</span> stringWithContentsOfFile: basicJsPath encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error: <span class="hljs-literal">nil</span>];
    <span class="hljs-keyword">return</span> basicString;
}] catch:^(<span class="hljs-built_in">NSError</span> * _Nonnull basicError) {
		<span class="hljs-comment">//处理加载js出错的情况</span>
    <span class="hljs-built_in">NSLogDebug</span>(<span class="hljs-string">@"❌---load basic js file:%@ faile--error:%@---❌"</span>, <span class="hljs-keyword">self</span>.lastPlanId, basicError);
}] then: ^<span class="hljs-built_in">NSString</span> * (<span class="hljs-keyword">void</span>) {
		<span class="hljs-comment">//第一个js执行完毕后,这里返回需要加载的第二个js文件</span>
    <span class="hljs-keyword">if</span> (isHaveMacro)
    {
        <span class="hljs-built_in">NSString</span> *macroString = [<span class="hljs-built_in">NSString</span> stringWithContentsOfFile: macroJsPath encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error: <span class="hljs-literal">nil</span>];
        <span class="hljs-keyword">return</span> macroString;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;
}] catch:^(<span class="hljs-built_in">NSError</span> *macroError) {
		<span class="hljs-comment">//处理加载js出错的情况</span>
    <span class="hljs-built_in">NSLogDebug</span>(<span class="hljs-string">@"❌---load macro js file:%@ faile--error:%@---❌"</span>, <span class="hljs-keyword">self</span>.lastPlanId, macroError);
}] then: ^<span class="hljs-built_in">NSString</span> * (<span class="hljs-keyword">void</span>) {
		<span class="hljs-comment">//通知webView,执行初始化操作</span>
    <span class="hljs-built_in">NSString</span> *javaScriptString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"setPlan('%@',%d)"</span>, <span class="hljs-keyword">self</span>.lastPlanId, isHaveMacro];
    <span class="hljs-keyword">return</span> javaScriptString;
}] catch:^(<span class="hljs-built_in">NSError</span> *setPlanError) {
    <span class="hljs-built_in">NSLogDebug</span>(<span class="hljs-string">@"❌---set plan:%@ faile--error:%@---❌"</span>, <span class="hljs-keyword">self</span>.lastPlanId, setPlanError);
}] finaly: ^<span class="hljs-built_in">NSString</span> * (<span class="hljs-keyword">void</span>) {
		<span class="hljs-comment">//初始化成功,调用native的计算方法.</span>
		[<span class="hljs-keyword">self</span> loadCalculate];
}];
</code></pre><h3>RJSEvalPromise 的实现逻辑</h3><p><code>firstlyWithJSEvaluator</code> 这个方法需要传两个参数,第一个是 JS 执行环境,也就是 <code>webView</code>, 第二个是一个回调函数,类型定义为 <code>typedef NSString *_Nullable(^SQSPromiseFirstCallback)(void);</code> ,回调函数调用后,返回的就是需要执行的 JS 代码,这里直接返回了 promise,却没对它强引用,会不会导致在 JS 执行前自动释放呢,答案是不会,因为在 <code>aciton</code> 实现中, <code>webView</code> 的回调函数会捕获这个 promise 对象</p><pre data-language="objectivec" class="hljs"><code><span class="hljs-comment">//RJSEvalPromise.m</span>
+ (<span class="hljs-keyword">instancetype</span>)firstlyWithJSEvaluator:(<span class="hljs-built_in">WKWebView</span> *)jsEvaluator js:(SQSPromiseFirstCallback)js {
    RJSEvalPromise* promise = [RJSEvalPromise makePromiseWithJSEvaluator: jsEvaluator js: js];
    promise.aciton();
    promise.aciton = <span class="hljs-literal">nil</span>;
    <span class="hljs-keyword">return</span> promise;
}
</code></pre><p><code>makePromiseWithJSEvaluator</code> 就是真正创建 promise 对象的方法,这里定义 promise 的具体执行逻辑,这里 promise 的 action 中直接使用了 promise,却不会循环引用的原因是上边在调用 action 后,直接把 action 手动置为 nil,消除了循环引用,但是编译器会弹出警告,所以加上 <code>diagnostic ignored</code> 让编译器忽略掉这个警告</p><pre data-language="objectivec" class="hljs"><code>+ (<span class="hljs-keyword">instancetype</span>)makePromiseWithJSEvaluator:(<span class="hljs-built_in">WKWebView</span> *)jsEvaluator js:(SQSPromiseFirstCallback)js{
    RJSEvalPromise * promise = [[RJSEvalPromise alloc] init];
    promise.jsEvaluator = jsEvaluator;
    promise.state = RJSEvalPromiseStatePending;
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic push</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic ignored <span class="hljs-meta-string">"-Warc-retain-cycles"</span></span>
    promise.aciton = ^{
        <span class="hljs-built_in">NSString</span> *string = js();
        <span class="hljs-comment">// if no need evaluateJavaScript, then Fulfilled.</span>
        <span class="hljs-keyword">if</span> (!string)
        {
            promise.state = RJSEvalPromiseStateFulfilled;
            [promise resume];
            <span class="hljs-keyword">return</span>;
        }
        [jsEvaluator evaluateJavaScript: string completionHandler:^(<span class="hljs-keyword">id</span> _Nullable result, <span class="hljs-built_in">NSError</span> * _Nullable error) {
            promise.result = result;
            promise.error = error;
            <span class="hljs-keyword">if</span> (error) {
                promise.state = RJSEvalPromiseStateRejected;
            }<span class="hljs-keyword">else</span>{
                promise.state = RJSEvalPromiseStateFulfilled;
            }
            [promise resume];
        }];
    };
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic pop</span>
    <span class="hljs-keyword">return</span> promise;
}
</code></pre><p>webView 调用<code>evaluateJavaScript</code> 方法,执行 JS 后,拿到执行的具体结果,给当前的 promise 赋值对应的状态.然后调用 <code>resume</code> 方法,看是否当前的 promise 链,已经调用完毕了</p><p><code>resume</code> 的实现就比较简单了,如果状态是 <code>Pending</code> 的话,直接返回,是 <code>Rejected</code> ,那么出现错误了,调 <code>catch</code> 回调函数,然后看是否有下一个 promise,有的话就执行它的 action 方法,直到 promise 链调用完毕</p><pre data-language="objectivec" class="hljs"><code>- (<span class="hljs-keyword">void</span>)resume {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.state == RJSEvalPromiseStatePending)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.state == RJSEvalPromiseStateRejected)
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.catchCallback) {
            <span class="hljs-keyword">self</span>.catchCallback(<span class="hljs-keyword">self</span>.error);
        }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.nextFuture.aciton) {
        <span class="hljs-keyword">self</span>.nextFuture.aciton();
    }
    <span class="hljs-keyword">self</span>.nextFuture.aciton = <span class="hljs-literal">nil</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.finalCallback) {
        <span class="hljs-keyword">self</span>.finalCallback(<span class="hljs-keyword">self</span>.result);
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.emptyFinalCallback) {
        <span class="hljs-keyword">self</span>.emptyFinalCallback();
    }
}
</code></pre><p>当然这里,也可以修改为,如果发生错误的话,就不再执行下一个 promise 了,直接循环查找最后一个 catch 回调.</p><pre data-language="objectivec" class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.state == RJSEvalPromiseStateRejected)
{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">self</span>.nextFuture &amp;&amp; <span class="hljs-keyword">self</span>.nextFuture.catchCallback) {
        <span class="hljs-keyword">self</span>.catchCallback = <span class="hljs-keyword">self</span>.nextFuture.catchCallback;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.catchCallback) {
        <span class="hljs-keyword">self</span>.catchCallback(<span class="hljs-keyword">self</span>.error);
    }
}
</code></pre><p>哦,对了,还有 <code>then</code> 方法,它的实现和 <code>firstlyWithJSEvaluator</code>基本相同,调用 <code>makePromiseWithJSEvaluator</code> 然后保存创建的这个 promise 对象.</p><pre data-language="objectivec" class="hljs"><code>- (<span class="hljs-keyword">instancetype</span>)then:(SQSPromiseFirstCallback)callback {
    RJSEvalPromise* promise = [RJSEvalPromise makePromiseWithJSEvaluator: <span class="hljs-keyword">self</span>.jsEvaluator js: callback];
    <span class="hljs-keyword">self</span>.nextFuture = promise;
    [<span class="hljs-keyword">self</span> resume];
    <span class="hljs-keyword">return</span> promise;
}
</code></pre><p>还有 <code>catch</code> 和 <code>finally</code> 方法都是仅仅保存了回调函数,等待执行 JS 出结果后,在 resume 方法中调用</p><pre data-language="objectivec" class="hljs"><code>- (<span class="hljs-keyword">instancetype</span>)catch:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSError</span> * _Nonnull))callback {
    <span class="hljs-keyword">self</span>.catchCallback = callback;
    [<span class="hljs-keyword">self</span> resume];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">void</span>)finally:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">void</span>))callback {
    <span class="hljs-keyword">self</span>.emptyFinalCallback = callback;
    [<span class="hljs-keyword">self</span> resume];
}
</code></pre><p>当然这样做,有一大堆的[] , <strong><code>如何通过.(点)调用方法呢?</code></strong> iOS 中使用点调用属性的本质都是调用属性的 getter 方法来获取属性值. 那么连续使用的.调用,需要满足什么条件呢？</p><blockquote><p>1: 必须是对象方法; 2: 必须有返回值,返回值的类型是当前对象类型 3: <strong>一定是没有参数的</strong></p></blockquote><p>看到第三点的要求,不能传参数,那怎么把要执行的 JS 传递过去呢? 那么可以做个变更,返回值不再是一个 promise 对像,而返回一个 block,这个 block,调用后,再返回个 promise 对象,就满足了要求</p><pre data-language="swift" class="hljs"><code>typedef <span class="hljs-type">RJSEvalPromise</span> *_Nullable(^<span class="hljs-type">SQSPromiseDotThen</span>)(<span class="hljs-type">SQSPromiseFirstCallback</span>);

- (<span class="hljs-type">SQSPromiseDotThen</span>)then {
    <span class="hljs-keyword">return</span> ^<span class="hljs-type">RJSEvalPromise</span> * _Nullable(<span class="hljs-type">SQSPromiseFirstCallback</span> _Nonnull callback) {
        <span class="hljs-type">RJSEvalPromise</span>* promise = [<span class="hljs-type">RJSEvalPromise</span> makePromiseWithJSEvaluator: <span class="hljs-keyword">self</span>.jsEvaluator js: callback jsResult: <span class="hljs-literal">nil</span> result: <span class="hljs-literal">nil</span>];
        <span class="hljs-keyword">self</span>.nextFuture = promise;
        [<span class="hljs-keyword">self</span> resume];
        <span class="hljs-keyword">return</span> promise;
    };
}
</code></pre><p>这样就达到了,使用.语法的链式调用了</p><pre data-language="swift" class="hljs"><code>[[<span class="hljs-type">RJSEvalPromise</span> firstlyWithJSEvaluator: webView js: ^<span class="hljs-type">NSString</span> * (void) {
    <span class="hljs-type">NSString</span> *basicString = [<span class="hljs-type">NSString</span> stringWithContentsOfFile: basicJsPath encoding:<span class="hljs-type">NSUTF8StringEncoding</span> error: <span class="hljs-literal">nil</span>];
    <span class="hljs-keyword">return</span> basicString;
}].dotThen(^<span class="hljs-type">NSString</span> * (void) {
    <span class="hljs-keyword">if</span> (isHaveMacro)
    {
        <span class="hljs-type">NSString</span> *macroString = [<span class="hljs-type">NSString</span> stringWithContentsOfFile: macroJsPath encoding:<span class="hljs-type">NSUTF8StringEncoding</span> error: <span class="hljs-literal">nil</span>];
        <span class="hljs-keyword">return</span> macroString;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;
}).dotThen(^<span class="hljs-type">NSString</span> * (void) {
    <span class="hljs-type">NSString</span> *javaScriptString = [<span class="hljs-type">NSString</span> stringWithFormat:@<span class="hljs-string">"setPlan('%@',%d)"</span>, <span class="hljs-keyword">self</span>.lastPlanId, isHaveMacro];
    <span class="hljs-keyword">return</span> javaScriptString;
}) finally:^{

}];
</code></pre><p>至此,完成了回调地狱到 promise 链式调用的转换.</p></div></div></article><div class="item-navigator"><table><tr><td></td><td></td></tr></table></div><footer><p>Copyright &copy; Restver 2023 <a href="http://beian.miit.gov.cn">京ICP备20015082</a></p><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><ul><li><a href="https://twitter.com/fatbobman">Twitter</a></li><li><a href="https://github.com/restver/">Github</a></li><li><a href="/feed.rss">RSS</a></li></ul><script>
    // dynamic User by Hux
    var _gaId = 'UA-165296388-1';
    var _gaDomain = 'fatbobman.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>

<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '14e5d60a3ea6276655f9d14c58b1fcd0';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script></footer></div></body></html>